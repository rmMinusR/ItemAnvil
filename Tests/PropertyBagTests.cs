using UnityEngine;
using UnityEngine.TestTools;
using NUnit.Framework;
using System;
using System.Collections.Generic;

namespace rmMinusR.ItemAnvil.Tests
{

    /// Generated by ChatGPT, using the following prompt:
    /// 
    /// A PropertyBag is a data structure similar to a Set, but entries must be unique by type. For example, adding the Marketable property once will succeed, but attempting to add a second Marketable will throw an error and make no changes, even if they have different data.
    ///
    /// Properties that go into the PropertyBag use inheritance. ItemProperty has the subclasses Marketable and MaxStackSize. ItemInstanceProperty has the subclass Temperature.
    /// 
    /// Using the outline below, generate a complete set of unit tests for PropertyBag using the Unity Test Framework.You may use the existing properties, or generate new types as needed.
    /// 
    /// (outline of public members)
    public class PropertyBagTests
    {
        [Test]
        public void Add_NewProperty_AddsSuccessfully()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();

            // Act
            bag.Add<Marketable>();

            // Assert
            Assert.IsTrue(bag.Contains<Marketable>());
        }

        [Test]
        public void Add_ExistingProperty_ThrowsError()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();
            bag.Add<Marketable>();

            // Act & Assert
            Assert.Throws<InvalidOperationException>(() => bag.Add<Marketable>());
        }

        [Test]
        public void Get_ExistingProperty_ReturnsProperty()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();
            bag.Add<Marketable>();

            // Act
            Marketable property = bag.Get<Marketable>();

            // Assert
            Assert.IsNotNull(property);
        }

        [Test]
        public void Get_NonExistingProperty_ReturnsNull()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();

            // Act
            Marketable property = bag.Get<Marketable>();

            // Assert
            Assert.IsNull(property);
        }

        [Test]
        public void Remove_ExistingProperty_RemovesSuccessfully()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();
            bag.Add<Marketable>();

            // Act
            bool result = bag.Remove<Marketable>();

            // Assert
            Assert.IsTrue(result);
            Assert.IsFalse(bag.Contains<Marketable>());
        }

        [Test]
        public void Remove_NonExistingProperty_ReturnsFalse()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();

            // Act
            bool result = bag.Remove<Marketable>();

            // Assert
            Assert.IsFalse(result);
        }

        [Test]
        public void ExceptWith_RemovesCommonProperties()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();
            bag1.Add<MaxStackSize>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<MaxStackSize>();

            // Act
            bag1.ExceptWith(bag2);

            // Assert
            Assert.IsFalse(bag1.Contains<MaxStackSize>());
            Assert.IsTrue(bag1.Contains<Marketable>());
        }

        [Test]
        public void IntersectWith_KeepsCommonProperties()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();
            bag1.Add<MaxStackSize>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<MaxStackSize>();

            // Act
            bag1.IntersectWith(bag2);

            // Assert
            Assert.IsTrue(bag1.Contains<MaxStackSize>());
            Assert.IsFalse(bag1.Contains<Marketable>());
        }

        [Test]
        public void IsProperSubsetOf_IsSubset_ReturnsTrue()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<Marketable>();
            bag2.Add<MaxStackSize>();

            // Act
            bool result = bag1.IsProperSubsetOf(bag2);

            // Assert
            Assert.IsTrue(result);
        }

        [Test]
        public void IsProperSubsetOf_NotSubset_ReturnsFalse()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<MaxStackSize>();

            // Act
            bool result = bag1.IsProperSubsetOf(bag2);

            // Assert
            Assert.IsFalse(result);
        }

        [Test]
        public void IsProperSupersetOf_IsSuperset_ReturnsTrue()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();
            bag1.Add<MaxStackSize>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<Marketable>();

            // Act
            bool result = bag1.IsProperSupersetOf(bag2);

            // Assert
            Assert.IsTrue(result);
        }

        [Test]
        public void IsProperSupersetOf_NotSuperset_ReturnsFalse()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<Marketable>();
            bag2.Add<MaxStackSize>();

            // Act
            bool result = bag1.IsProperSupersetOf(bag2);

            // Assert
            Assert.IsFalse(result);
        }

        [Test]
        public void IsSubsetOf_IsSubset_ReturnsTrue()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<Marketable>();
            bag2.Add<MaxStackSize>();

            // Act
            bool result = bag1.IsSubsetOf(bag2);

            // Assert
            Assert.IsTrue(result);
        }

        [Test]
        public void IsSubsetOf_NotSubset_ReturnsFalse()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<MaxStackSize>();

            // Act
            bool result = bag1.IsSubsetOf(bag2);

            // Assert
            Assert.IsFalse(result);
        }

        [Test]
        public void IsSupersetOf_IsSuperset_ReturnsTrue()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();
            bag1.Add<MaxStackSize>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<Marketable>();

            // Act
            bool result = bag1.IsSupersetOf(bag2);

            // Assert
            Assert.IsTrue(result);
        }

        [Test]
        public void IsSupersetOf_NotSuperset_ReturnsFalse()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<Marketable>();
            bag2.Add<MaxStackSize>();

            // Act
            bool result = bag1.IsSupersetOf(bag2);

            // Assert
            Assert.IsFalse(result);
        }

        [Test]
        public void Overlaps_CommonProperties_ReturnsTrue()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();
            bag1.Add<MaxStackSize>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<MaxStackSize>();

            // Act
            bool result = bag1.Overlaps(bag2);

            // Assert
            Assert.IsTrue(result);
        }

        [Test]
        public void Overlaps_NoCommonProperties_ReturnsFalse()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<MaxStackSize>();

            // Act
            bool result = bag1.Overlaps(bag2);

            // Assert
            Assert.IsFalse(result);
        }

        [Test]
        public void SetEquals_SameProperties_ReturnsTrue()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();
            bag1.Add<MaxStackSize>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<MaxStackSize>();
            bag2.Add<Marketable>();

            // Act
            bool result = bag1.SetEquals(bag2);

            // Assert
            Assert.IsTrue(result);
        }

        [Test]
        public void SetEquals_DifferentProperties_ReturnsFalse()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<MaxStackSize>();

            // Act
            bool result = bag1.SetEquals(bag2);

            // Assert
            Assert.IsFalse(result);
        }
    }

}