using UnityEngine;
using UnityEngine.TestTools;
using NUnit.Framework;
using System;
using System.Collections.Generic;
using System.Linq;

namespace rmMinusR.ItemAnvil.Tests
{

    /// Generated by ChatGPT, using the following prompt:
    /// 
    /// A PropertyBag is a data structure similar to a Set, but entries must be unique by type. For example, adding the Marketable property once will succeed, but attempting to add a second Marketable will throw an error and make no changes, even if they have different data.
    ///
    /// Properties that go into the PropertyBag use inheritance. ItemProperty has the subclasses Marketable and MaxStackSize. ItemInstanceProperty has the subclass Temperature.
    /// 
    /// Using the outline below, generate a complete set of unit tests for PropertyBag using the Unity Test Framework.You may use the existing properties, or generate new types as needed.
    /// 
    /// (outline of public members)
    public class PropertyBagTests
    {
        [Test]
        public void Add_NewProperty_AddsSuccessfully()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();

            // Act
            bag.Add<Marketable>();

            // Assert
            Assert.IsTrue(bag.Contains<Marketable>());
        }

        [Test]
        public void Add_ExistingProperty_ThrowsError()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();
            bag.Add<Marketable>();

            // Act & Assert
            Assert.Throws<InvalidOperationException>(() => bag.Add<Marketable>());
        }

        [Test]
        public void Get_ExistingProperty_ByGeneric_ReturnsProperty()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();
            bag.Add<Marketable>();

            // Act
            Marketable property = bag.Get<Marketable>();

            // Assert
            Assert.IsNotNull(property);
        }

        [Test]
        public void Get_MissingProperty_ByGeneric_ReturnsNull()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();

            // Act
            Marketable property = bag.Get<Marketable>();

            // Assert
            Assert.IsNull(property);
        }

        [Test]
        public void Get_ExistingProperty_ByTypeVar_ReturnsProperty()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();
            bag.Add<Marketable>();

            // Act
            Marketable property = (Marketable)bag.Get(typeof(Marketable));

            // Assert
            Assert.IsNotNull(property);
        }

        [Test]
        public void Get_MissingProperty_ByTypeVar_ReturnsNull()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();

            // Act
            Marketable property = (Marketable)bag.Get(typeof(Marketable));

            // Assert
            Assert.IsNull(property);
        }

        [Test]
        public void TryGet_ExistingProperty_ReturnsTrueAndProperty()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();
            bag.Add<Marketable>();

            // Act
            bool ret = bag.TryGet(out Marketable property);

            // Assert
            Assert.IsTrue(ret);
            Assert.IsNotNull(property);
        }

        [Test]
        public void TryGet_MissingProperty_ReturnsFalseAndNull()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();
            
            // Act
            bool ret = bag.TryGet(out Marketable property);
            
            // Assert
            Assert.IsFalse(ret);
            Assert.IsNull(property);
        }

        [Test]
        public void Remove_ExistingProperty_RemovesSuccessfully()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();
            bag.Add<Marketable>();

            // Act
            bool result = bag.Remove<Marketable>();

            // Assert
            Assert.IsTrue(result);
            Assert.IsFalse(bag.Contains<Marketable>());
        }

        [Test]
        public void Remove_NonExistingProperty_ReturnsFalse()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();

            // Act
            bool result = bag.Remove<Marketable>();

            // Assert
            Assert.IsFalse(result);
        }

        [Test]
        public void Contains_Existing_ReturnsTrue()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();
            bag.Add<Marketable>();

            // Act
            bool ret = bag.Contains<Marketable>();

            // Assert
            Assert.IsTrue(ret);
        }

        [Test]
        public void Contains_Nonexisting_ReturnsFalse()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();
            bag.Add<Marketable>();

            // Act
            bool ret = bag.Contains<MaxStackSize>();

            // Assert
            Assert.IsFalse(ret);
        }

        [Test]
        public void Clear_RemovesAll()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();
            bag.Add<Marketable>();

            // Act
            bag.Clear();

            // Assert
            Assert.AreEqual(0, bag.Count);
        }

        [Test]
        public void CopyTo_ExactlyEnoughSpace_NoOffset_CopiesElements()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();
            bag.Add<Marketable>();
            bag.Add<MaxStackSize>();

            // Act
            ItemProperty[] props = new ItemProperty[2];
            bag.CopyTo(props, 0);

            // Assert
            Assert.AreEqual(1, props.Count(i => i is Marketable));
            Assert.AreEqual(1, props.Count(i => i is MaxStackSize));
        }

        [Test]
        public void CopyTo_MoreThanEnoughSpace_NoOffset_CopiesElements()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();
            bag.Add<Marketable>();
            bag.Add<MaxStackSize>();

            // Act
            ItemProperty[] props = new ItemProperty[4];
            bag.CopyTo(props, 0);

            // Assert
            Assert.AreEqual(1, props.Count(i => i is Marketable));
            Assert.AreEqual(1, props.Count(i => i is MaxStackSize));
            Assert.IsNull(props[2]);
            Assert.IsNull(props[3]);
        }

        [Test]
        public void CopyTo_NotEnoughSpace_NoOffset_CopiesElements()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();
            bag.Add<Marketable>();
            bag.Add<MaxStackSize>();

            // Act & Assert
            ItemProperty[] props = new ItemProperty[1];
            Assert.Throws<IndexOutOfRangeException>(() => bag.CopyTo(props, 0));
        }

        [Test]
        public void CopyTo_ExactlyEnoughSpace_WithOffset_CopiesElements()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();
            bag.Add<Marketable>();
            bag.Add<MaxStackSize>();

            // Act
            ItemProperty[] props = new ItemProperty[3];
            bag.CopyTo(props, 1);

            // Assert
            Assert.AreEqual(1, props.Count(i => i is Marketable));
            Assert.AreEqual(1, props.Count(i => i is MaxStackSize));
        }

        [Test]
        public void CopyTo_MoreThanEnoughSpace_WithOffset_CopiesElements()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();
            bag.Add<Marketable>();
            bag.Add<MaxStackSize>();

            // Act
            ItemProperty[] props = new ItemProperty[5];
            bag.CopyTo(props, 1);

            // Assert
            Assert.IsNull(props[0]);
            Assert.AreEqual(1, props.Count(i => i is Marketable));
            Assert.AreEqual(1, props.Count(i => i is MaxStackSize));
            Assert.IsNull(props[3]);
            Assert.IsNull(props[4]);
        }

        [Test]
        public void CopyTo_NotEnoughSpace_WithOffset_CopiesElements()
        {
            // Arrange
            PropertyBag<ItemProperty> bag = new PropertyBag<ItemProperty>();
            bag.Add<Marketable>();
            bag.Add<MaxStackSize>();

            // Act & Assert
            ItemProperty[] props = new ItemProperty[2];
            Assert.Throws<IndexOutOfRangeException>(() => bag.CopyTo(props, 1));
        }

        [Test]
        public void ExceptWith_RemovesCommonProperties()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();
            bag1.Add<MaxStackSize>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<MaxStackSize>();

            // Act
            bag1.ExceptWith(bag2);

            // Assert
            Assert.IsFalse(bag1.Contains<MaxStackSize>());
            Assert.IsTrue(bag1.Contains<Marketable>());
        }

        [Test]
        public void IntersectWith_KeepsCommonProperties()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();
            bag1.Add<MaxStackSize>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<MaxStackSize>();

            // Act
            bag1.IntersectWith(bag2);

            // Assert
            Assert.IsTrue(bag1.Contains<MaxStackSize>());
            Assert.IsFalse(bag1.Contains<Marketable>());
        }

        [Test]
        public void IsProperSubsetOf_IsSubset_ReturnsTrue()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<Marketable>();
            bag2.Add<MaxStackSize>();

            // Act
            bool result = bag1.IsProperSubsetOf(bag2);

            // Assert
            Assert.IsTrue(result);
        }

        [Test]
        public void IsProperSubsetOf_NotSubset_ReturnsFalse()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<MaxStackSize>();

            // Act
            bool result = bag1.IsProperSubsetOf(bag2);

            // Assert
            Assert.IsFalse(result);
        }

        [Test]
        public void IsProperSupersetOf_IsSuperset_ReturnsTrue()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();
            bag1.Add<MaxStackSize>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<Marketable>();

            // Act
            bool result = bag1.IsProperSupersetOf(bag2);

            // Assert
            Assert.IsTrue(result);
        }

        [Test]
        public void IsProperSupersetOf_NotSuperset_ReturnsFalse()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<Marketable>();
            bag2.Add<MaxStackSize>();

            // Act
            bool result = bag1.IsProperSupersetOf(bag2);

            // Assert
            Assert.IsFalse(result);
        }

        [Test]
        public void IsSubsetOf_IsSubset_ReturnsTrue()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<Marketable>();
            bag2.Add<MaxStackSize>();

            // Act
            bool result = bag1.IsSubsetOf(bag2);

            // Assert
            Assert.IsTrue(result);
        }

        [Test]
        public void IsSubsetOf_NotSubset_ReturnsFalse()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<MaxStackSize>();

            // Act
            bool result = bag1.IsSubsetOf(bag2);

            // Assert
            Assert.IsFalse(result);
        }

        [Test]
        public void IsSupersetOf_IsSuperset_ReturnsTrue()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();
            bag1.Add<MaxStackSize>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<Marketable>();

            // Act
            bool result = bag1.IsSupersetOf(bag2);

            // Assert
            Assert.IsTrue(result);
        }

        [Test]
        public void IsSupersetOf_NotSuperset_ReturnsFalse()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<Marketable>();
            bag2.Add<MaxStackSize>();

            // Act
            bool result = bag1.IsSupersetOf(bag2);

            // Assert
            Assert.IsFalse(result);
        }

        [Test]
        public void Overlaps_CommonProperties_ReturnsTrue()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();
            bag1.Add<MaxStackSize>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<MaxStackSize>();

            // Act
            bool result = bag1.Overlaps(bag2);

            // Assert
            Assert.IsTrue(result);
        }

        [Test]
        public void Overlaps_NoCommonProperties_ReturnsFalse()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<MaxStackSize>();

            // Act
            bool result = bag1.Overlaps(bag2);

            // Assert
            Assert.IsFalse(result);
        }

        [Test]
        public void SetEquals_SameProperties_ReturnsTrue()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();
            bag1.Add<MaxStackSize>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<MaxStackSize>();
            bag2.Add<Marketable>();

            // Act
            bool result = bag1.SetEquals(bag2);

            // Assert
            Assert.IsTrue(result);
        }

        [Test]
        public void SetEquals_DifferentProperties_ReturnsFalse()
        {
            // Arrange
            PropertyBag<ItemProperty> bag1 = new PropertyBag<ItemProperty>();
            bag1.Add<Marketable>();

            PropertyBag<ItemProperty> bag2 = new PropertyBag<ItemProperty>();
            bag2.Add<MaxStackSize>();

            // Act
            bool result = bag1.SetEquals(bag2);

            // Assert
            Assert.IsFalse(result);
        }
    }

}